---
title: "gapminder"
output: html_document
---

Data Subsetting:

Given:

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
print(x)
```

Come up with commands to produce output without a and e.

```{r}
x[c(-1, -5)]
x[2:4]
x[c(2,3,4)]
x[c("b", "c", "d")]
```

Write commands to return values greater than 4 and less than 7.

```{r}
x[x > 4 & x < 7]
```

Load the gapminder data set. The online hosted version is used, but the source file is saved in dataSources.

```{r}
gapminder <- read.csv("https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/main/episodes/data/gapminder_data.csv")
```

Create a list of countries in in Southeast Asia, and a list of all countries in the gapminder data.

```{r}
seAsia <- c("Myanmar", "Thailand", "Cambodia", "Vietnam", "Laos")
countries <- unique(as.character(gapminder$country))
```

There are three theoretical ways to produce a logical vector to find all entries in Southeast Asia. Only two work.

This causes issues where all output values are false, as none of the recycled value in seAsia line up properly with the countries list.

```{r}
countries[countries==seAsia]
```

A clunky way to solve this problem is to test each country with or testing.

```{r}
countries[countries=="Myanmar"|countries=="Thailand"|countries=="Cambodia"|countries=="Vietnam"|countries=="Laos"]
```

The clean way to solve this problem is using the %in% operator, which goes through each element on the left and checks against each of the right.

```{r}
countries[countries %in% seAsia]
```

When dealing with missing/undefined/infinite data, R has special functions. is.na returns all positions in vectors/matrix/DFs containing NA or NaN. is.nan does the same solely for NaN, and is.infinite does the same for Inf.

is.finite returns all positions that do not contain NA, NaN, or Inf, and na.omit filters all missing values from a vector.

Given:

```{r}
m <- matrix(1:18, nrow=3, ncol=6)
print(m)
```

To extract 11 and 14, you can run:

```{r}
m[2,c(4,5)]
```

This works as matrix subsetting acts by row then column, leaving one blank returns all rows/columns respectively. If this is done, R returns a vector. Matrix output can be forced using drop = FALSE as a third argument.

Given list:

```{r}
xlist <- list(a = "Software Carpentry", b = 1:10, data = head(mtcars))
```

To extract the number 2, you would:

```{r}
xlist[[2]][2]
xlist$b[2]
```